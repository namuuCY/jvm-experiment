<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G1GC 작동 원리 상세 분석</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Inter 폰트 설정 */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body { font-family: 'Inter', sans-serif; }

        /* Voxel Grid Styling */
        .region-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr); /* 10x10 Grid */
            grid-template-rows: repeat(10, 1fr);
            aspect-ratio: 1 / 1;
            max-width: 600px;
            margin: 0 auto;
            border: 4px solid #1f2937; /* Dark border for the heap */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border-radius: 0.5rem;
            background-color: #f3f4f6;
        }
        .region {
            padding: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
            color: #fff;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            cursor: default;
            user-select: none;
            border: 1px solid rgba(0, 0, 0, 0.1);
            position: relative; /* For the tooltip positioning */
        }
        .region:hover {
            transform: scale(1.05);
            z-index: 10;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
        }

        /* Color Coding for Regions */
        .R_EMPTY { background-color: #e5e7eb; color: #6b7280; } /* Light Gray */
        .R_EDEN { background-color: #3b82f6; } /* Blue */
        .R_SURVIVOR { background-color: #f59e0b; } /* Amber */
        .R_OLD { background-color: #10b981; } /* Emerald */
        .R_HUMONGOUS { background-color: #ef4444; } /* Red */
        .R_CSET { background-color: #8b5cf6; animation: pulse-cset 1s infinite; } /* Violet (Selected for collection) */
        .R_EVACUATING { background-color: #f97316; animation: flash-evac 0.5s infinite; } /* Orange (Currently evacuating) */
        .R_TO_SPACE { background-color: #1f2937; } /* Dark (Target space for compaction) */

        /* Custom Animations */
        @keyframes pulse-cset {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        @keyframes flash-evac {
            0%, 100% { background-color: #f97316; }
            50% { background-color: #fcd34d; }
        }
        /* New Blinking Animation for Regions about to be emptied/moved */
        @keyframes critical-blink {
            0%, 100% { opacity: 1; transform: scale(1.05); }
            50% { opacity: 0.4; transform: scale(1.0); }
        }
        .R_CRITICAL_BLITZ {
            animation: critical-blink 0.2s ease-in-out 25 forwards; /* 25 blinks over 5 seconds (0.2s * 25) */
            z-index: 100; /* Ensure visibility */
        }

        /* Tooltip/Hover Card Styling */
        .tooltip-card {
            position: absolute;
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-left: 10px;
            min-width: 250px;
            background: #1f2937; /* Dark background */
            color: #f3f4f6; /* Light text */
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
            border: 2px solid #a855f7; /* Violet accent */
            z-index: 50; /* Ensure it is above other regions */
            pointer-events: none; /* Allows clicks through the card */
            opacity: 0;
            transition: opacity 0.15s ease-in-out;
        }

        .region:hover .tooltip-card {
            opacity: 1;
        }

        /* Responsive Layout for Explanation */
        .explainer-content {
            columns: 1;
        }
        @media (min-width: 768px) {
            .explainer-content {
                columns: 2; /* Two columns on desktop */
                column-gap: 3rem;
            }
        }
    </style>
</head>
<body class="bg-gray-50 p-4 sm:p-8">

<div class="max-w-7xl mx-auto">
    <header class="text-center mb-12">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-gray-900 mb-2">
            G1GC(Garbage-First Garbage Collector) 시각화 분석
        </h1>
        <p class="text-xl text-indigo-600">
            2D 시뮬레이션으로 보는 JVM 힙 메모리 관리
        </p>
    </header>

    <!-- Main Visualization Section -->
    <section class="mb-12 p-6 bg-white rounded-xl shadow-2xl border border-gray-100">
        <h2 id="current-phase" class="text-3xl font-bold text-center mb-6 text-indigo-700">현재 단계: 대기 중 - 아래 버튼을 눌러 시작하세요</h2>

        <div class="flex flex-col lg:flex-row gap-8">
            <!-- Voxel Grid (Heap) -->
            <div class="lg:w-1/2">
                <div id="heap-grid" class="region-grid">
                    <!-- Regions will be inserted here by JavaScript -->
                </div>
            </div>

            <!-- Controls and Legend -->
            <div class="lg:w-1/2">
                <div class="flex justify-center space-x-4 mb-6">
                    <button id="next-phase-btn" class="px-6 py-3 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold rounded-lg shadow-md transition duration-150">
                        시뮬레이션 시작 (다음 단계)
                    </button>
                </div>

                <div class="p-4 bg-gray-100 rounded-lg shadow-inner">
                    <h3 class="text-xl font-semibold mb-3 text-gray-800">리전 타입 범례</h3>
                    <div class="grid grid-cols-2 gap-3 text-sm">
                        <div class="flex items-center"><span class="w-4 h-4 rounded-sm mr-2 R_EDEN"></span>에덴 (Eden)</div>
                        <div class="flex items-center"><span class="w-4 h-4 rounded-sm mr-2 R_SURVIVOR"></span>서바이버 (Survivor)</div>
                        <div class="flex items-center"><span class="w-4 h-4 rounded-sm mr-2 R_OLD"></span>올드 (Old)</div>
                        <div class="flex items-center"><span class="w-4 h-4 rounded-sm mr-2 R_HUMONGOUS"></span>휴먼저스 (Humongous)</div>
                        <div class="flex items-center"><span class="w-4 h-4 rounded-sm mr-2 R_CSET"></span>컬렉션 셋 (CSET)</div>
                        <div class="flex items-center"><span class="w-4 h-4 rounded-sm mr-2 R_TO_SPACE"></span>이동 대상 (To Space)</div>
                        <div class="flex items-center"><span class="w-4 h-4 rounded-sm mr-2 R_EVACUATING"></span>비우는 중 (Evacuating)</div>
                        <div class="flex items-center"><span class="w-4 h-4 rounded-sm mr-2 R_EMPTY"></span>비어있음 (Empty)</div>
                    </div>
                </div>
                <p id="simulation-info" class="mt-4 text-center text-gray-600">
                    리전 위에 마우스를 올려 데이터 변환 정보를 확인하세요.
                </p>
            </div>
        </div>
    </section>

    <!-- Detailed Explanation Section -->
    <section class="p-6 bg-white rounded-xl shadow-2xl border border-gray-100">
        <h2 class="text-3xl font-bold text-gray-900 mb-6 border-b pb-2">G1GC 상세 설명 (한국어)</h2>
        <div class="explainer-content text-gray-700 text-lg leading-relaxed">

            <h3 class="text-2xl font-semibold text-indigo-700 mt-4 mb-2">1. G1GC의 기본 구조: 리전(Region)</h3>
            <p class="mb-4">
                G1GC는 기존의 Young/Old 영역 기반이 아닌, 힙을 크기가 같은 수많은 <strong class="text-red-500">리전(Region)</strong>으로 나눕니다. 이 리전은 필요에 따라 Young (Eden/Survivor), Old, 또는 Humongous 영역의 역할을 수행합니다. 이 구조 덕분에 GC가 힙 전체를 스캔하지 않고, 가장 효율적인 리전(가장 많은 가비지가 있는 리전)을 먼저 청소하여 **"Garbage First"**라는 이름이 붙었습니다.
            </p>

            <h3 class="text-2xl font-semibold text-indigo-700 mt-4 mb-2">2. 목표: 최대 일시 정지 시간 (Pause Time Target)</h3>
            <p class="mb-4">
                G1GC의 핵심 목표는 사용자가 설정한 <strong class="text-red-500">최대 일시 정지 시간(Max Pause Time Target)</strong>을 지키는 것입니다. GC는 이 목표 시간을 달성하기 위해, 청소할 리전들 중에서 가비지 회수에 걸리는 시간이 가장 적게 걸릴 것으로 예상되는 리전들을 선택하여 <strong class="text-purple-600">컬렉션 셋(CSET)</strong>을 구성합니다.
            </p>

            <h3 class="text-2xl font-semibold text-indigo-700 mt-4 mb-2">3. Young GC (Minor GC)</h3>
            <p class="mb-4">
                Young GC는 **Stop-The-World (STW)** 단계입니다. Eden과 Survivor 리전에서 진행되며, 새로 생성된 객체 중 살아있는 객체들을 다른 Survivor 리전이나 Old 리전으로 이동(Evacuation)시킵니다. 이동 후, 기존의 Young 리전들은 **Empty(비어있음)** 상태로 재활용됩니다. G1GC는 이 Young GC 단계에서 CSET을 통해 이동하는 **동시에** 메모리를 압축(Compaction)합니다.
            </p>

            <h3 class="text-2xl font-semibold text-indigo-700 mt-4 mb-2">4. Concurrent Cycle (동시 사이클)</h3>
            <p class="mb-4">
                Old 리전의 사용량이 임계점(Initial Mark Threshold)을 넘으면 동시 사이클이 시작됩니다. 이 사이클은 애플리케이션 스레드와 **동시에** 진행되어 STW 시간을 최소화합니다.
            </p>
            <ul class="list-disc ml-6 space-y-2 mb-4">
                <li><strong class="text-blue-600">초기 마킹 (Initial Mark):</strong> STW 단계. 힙의 루트(GC Root)에서 직접 참조되는 객체들만 마킹합니다. 이 단계는 Young GC 도중에 함께 진행되어 별도의 STW 시간을 줄이는 경우가 많습니다.</li>
                <li><strong class="text-blue-600">동시 마킹 (Concurrent Marking):</strong> STW 없이 애플리케이션과 동시에 Old 리전에 있는 객체의 생존 여부를 트래킹합니다. 이때 <strong class="text-red-500">S.A.T (Snapshot-At-The-Beginning)</strong> 알고리즘을 사용하여 마킹 시작 시점의 스냅샷을 기준으로 작업합니다.</li>
                <li><strong class="text-blue-600">리마크 (Remark):** 짧은 STW 단계. 동시 마킹 중에 변경된 사항을 최종적으로 반영하고, 필요 없는 객체를 제거합니다.</li>
                <li><strong class="text-blue-600">클린업 (Cleanup):</strong> 짧은 STW 단계. 마킹이 완료된 후, 가비지만 남아있는 리전들을 식별하고 힙에서 제거합니다. 완전히 비어있는 리전은 즉시 <strong class="text-gray-500">Empty</strong>로 반환됩니다.</li>
            </ul>

            <h3 class="text-2xl font-semibold text-indigo-700 mt-4 mb-2">5. Mixed GC (복합 GC)</h3>
            <p class="mb-4">
                동시 사이클이 Old 리전에 가비지가 많음을 확인하면, G1GC는 Old 리전을 포함하여 GC를 수행하는 **Mixed GC** 단계를 시작합니다. 이 단계도 STW이며, Young GC와 동일하게 **CSET**에 포함된 Young 리전과 Old 리전의 **모든** 살아있는 객체를 새로운 Empty 리전으로 복사(Evacuate)하면서 압축을 수행합니다.
            </p>

            <h3 class="text-2xl font-semibold text-indigo-700 mt-4 mb-2">6. 휴먼저스 객체 처리 (Humongous Object Handling)</h3>
            <p class="mb-4">
                리전 크기의 50%를 초과하는 매우 큰 객체는 <strong class="text-red-500">휴먼저스(Humongous) 리전</strong>에 할당됩니다. 이 객체들은 대부분 Young GC나 Mixed GC에서 처리되지 않고, 동시 마킹 단계에서 수집 대상이 될 수 있습니다.
            </p>

            <div class="p-4 bg-yellow-100 border-l-4 border-yellow-500 text-yellow-800 rounded-md mt-6">
                <p class="font-bold">데이터 변환 흐름 요약:</p>
                <p class="mt-1 text-sm">
                    <strong class="text-blue-600">Eden/Survivor</strong> (Young GC) &rarr; 살아남은 객체는 <strong class="text-orange-500">To Space (새로운 Survivor/Old)</strong>로 이동 및 압축 &rarr; 기존 리전은 <strong class="text-gray-500">Empty</strong>로 변환.<br>
                    <strong class="text-green-600">Old</strong> (Mixed GC) &rarr; CSET에 선택 &rarr; 살아남은 객체는 <strong class="text-orange-500">To Space (새로운 Old)</strong>로 이동 및 압축 &rarr; 기존 리전은 <strong class="text-gray-500">Empty</strong>로 변환.
                </p>
            </div>
        </div>
    </section>
</div>

<script>
    // Constants
    const GRID_SIZE = 10;
    const NUM_REGIONS = GRID_SIZE * GRID_SIZE;
    const HEAP_GRID = document.getElementById('heap-grid');
    const CURRENT_PHASE_DISPLAY = document.getElementById('current-phase');
    const NEXT_PHASE_BTN = document.getElementById('next-phase-btn');
    const OLD_REGION_THRESHOLD = 0.45; // 45% of total regions (for visual demo purpose)
    const BLINK_DURATION_MS = 5000; // 5 seconds for blinking (25 blinks * 0.2s/blink)

    // Region State Definition
    const RegionTypes = {
        EMPTY: 'EMPTY',
        EDEN: 'EDEN',
        SURVIVOR: 'SURVIVOR',
        OLD: 'OLD',
        HUMONGOUS: 'HUMONGOUS',
        CSET: 'CSET', // Collection Set - selected for GC
        EVACUATING: 'EVACUATING', // Target during evacuation - Visually used, but functionally replaced by instant CSET->EMPTY
        TO_SPACE: 'TO_SPACE', // New space for evacuated objects
    };

    // Global State
    let regions = [];
    let currentPhaseIndex = 0;

    // Phase Definitions (Simplified Flow for Visualization)
    const phases = [
        { name: "0. 초기 힙 구성 (Initial Heap Setup)", action: setupInitialHeap },
        { name: "1. Young GC 시작: Initial Mark (STW)", action: startYoungGC },
        { name: "2. Young GC: Evacuation 및 Compaction 완료", action: evacuateYoung },
        { name: "3. Old 영역 임계점 도달 (Concurrent Cycle 시작)", action: startConcurrentMark },
        { name: "4. Concurrent Marking 진행 중 (동시 추적)", action: processConcurrentMark },
        { name: "5. Remark 및 Cleanup 완료 (STW)", action: processRemarkCleanup },
        { name: "6. Mixed GC 시작: CSET 선정", action: startMixedGC },
        { name: "7. Mixed GC: Compaction 및 비우기 완료", action: evacuateMixed },
        { name: "8. 휴먼저스 객체 처리 (Optional Cleanup)", action: processHumongous },
    ];

    /**
     * Helper to get random integer
     */
    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    /**
     * 힙 리전 데이터를 초기화하고 렌더링합니다.
     */
    function initializeRegions() {
        regions = [];
        for (let i = 0; i < NUM_REGIONS; i++) {
            regions.push({
                id: i,
                type: RegionTypes.EMPTY,
                live_objects: 0,
                memory_usage: '0%',
                data_history: [{ phase: "초기화", status: "비어있음" }]
            });
        }
    }

    /**
     * DOM에 리전 엘리먼트를 생성하고 바인딩합니다.
     */
    function renderRegions() {
        HEAP_GRID.innerHTML = '';
        regions.forEach(region => {
            const div = document.createElement('div');
            div.className = `region R_${region.type} rounded-sm`;
            div.id = `region-${region.id}`;

            // Tooltip Card Setup
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip-card';
            div.appendChild(tooltip);

            // Add hover event listener (using CSS :hover for visibility, JS for content)
            div.onmouseover = () => updateTooltipContent(region.id, tooltip);

            HEAP_GRID.appendChild(div);
        });
        updateRegionClasses(); // Initial class update
    }

    /**
     * 마우스를 올렸을 때 툴팁의 내용을 업데이트합니다.
     */
    function updateTooltipContent(id, tooltip) {
        const region = regions[id];
        const lastHistory = region.data_history[region.data_history.length - 1];

        let historyHtml = region.data_history.map(h => `
            <li class="mb-1 p-1 bg-gray-800 rounded">
                <strong>${h.phase}:</strong> ${h.status}
            </li>
        `).join('');

        tooltip.innerHTML = `
            <h4 class="font-bold text-lg mb-1 text-purple-400">리전 #${region.id} 상세</h4>
            <p class="text-sm"><strong>타입:</strong> ${getRegionTypeKorean(region.type)}</p>
            <p class="text-sm"><strong>객체 수:</strong> ${region.live_objects}</p>
            <p class="text-sm"><strong>사용량:</strong> ${region.memory_usage}</p>
            <p class="text-sm border-t border-gray-600 mt-2 pt-2"><strong>현재 상태 (소스):</strong> ${lastHistory.status}</p>

            <h5 class="font-semibold text-base mt-3 mb-1 border-t border-gray-600 pt-2">데이터 변환 과정 (기록)</h5>
            <ul class="list-none text-xs max-h-40 overflow-y-auto">
                ${historyHtml}
            </ul>
        `;
    }

    /**
     * 리전 타입 영어를 한국어로 변환합니다.
     */
    function getRegionTypeKorean(type) {
        switch (type) {
            case RegionTypes.EMPTY: return '비어있음 (Empty)';
            case RegionTypes.EDEN: return '에덴 (Eden)';
            case RegionTypes.SURVIVOR: return '서바이버 (Survivor)';
            case RegionTypes.OLD: return '올드 (Old)';
            case RegionTypes.HUMONGOUS: return '휴먼저스';
            case RegionTypes.CSET: return '컬렉션 셋 (CSET)';
            case RegionTypes.EVACUATING: return '비우는 중';
            case RegionTypes.TO_SPACE: return '이동 대상 (To Space)';
            default: return '알 수 없음';
        }
    }

    /**
     * 힙 리전의 CSS 클래스를 업데이트합니다.
     */
    function updateRegionClasses() {
        regions.forEach(region => {
            const el = document.getElementById(`region-${region.id}`);
            if (el) {
                // Remove all type classes first, excluding the blink class
                el.className = el.className.split(' ').filter(c => !c.startsWith('R_') || c === 'R_CRITICAL_BLITZ').join(' ');
                // Add the new type class
                el.classList.add(`R_${region.type}`);
                el.textContent = region.type === RegionTypes.EMPTY ? '' : (region.live_objects > 0 ? region.live_objects : '');
            }
        });
    }

    /**
     * 리전의 상태를 변경하고 히스토리를 기록합니다.
     */
    function setRegionState(region, type, phaseName, status) {
        if (region.type !== type) {
            // Only update history if the state actually changes
            region.data_history.push({ phase: phaseName, status: status });
        }
        region.type = type;

        // Update objects and usage based on new type
        if (type === RegionTypes.EMPTY) {
            region.live_objects = 0;
            region.memory_usage = '0%';
        } else if (type === RegionTypes.EDEN) {
            region.live_objects = getRandomInt(800, 1500);
            region.memory_usage = getRandomInt(70, 95) + '%';
        } else if (type === RegionTypes.SURVIVOR || type === RegionTypes.OLD) {
            region.live_objects = getRandomInt(100, 800);
            region.memory_usage = getRandomInt(30, 80) + '%';
        } else if (type === RegionTypes.TO_SPACE) {
            // Target space is momentarily full of new/copied objects
            region.live_objects = getRandomInt(500, 1200);
            region.memory_usage = getRandomInt(80, 100) + '%';
        }
    }

    // --- BLINKING LOGIC ---

    /**
     * 특정 단계에서 제거되거나 이동될 리전을 찾습니다.
     */
    function getRegionsForBlink(phaseName) {
        switch (phaseName) {
            case "2. Young GC: Evacuation 및 Compaction 완료":
                // Blink CSET (Eden/Survivor) regions before they become EMPTY
                return regions.filter(r => r.type === RegionTypes.EDEN || r.type === RegionTypes.SURVIVOR);
            case "7. Mixed GC: Compaction 및 비우기 완료":
                // Blink CSET regions before they become EMPTY
                return regions.filter(r => r.type === RegionTypes.CSET);
            case "8. 휴먼저스 객체 처리 (Optional Cleanup)":
                // Blink Humongous regions that are about to be collected (Simulated: all of them)
                // Note: Actual G1GC only collects Humongous regions that are dead. We blink all for demo.
                return regions.filter(r => r.type === RegionTypes.HUMONGOUS);
            default:
                return [];
        }
    }

    /**
     * 특정 리전들을 점멸시키고 지정된 시간 후에 콜백 함수를 실행합니다.
     * @param {Array<Object>} regionsToBlink - 점멸할 리전 객체 배열.
     * @param {function} callback - 점멸 후 실행할 함수.
     */
    function blinkRegions(regionsToBlink, callback) {
        regionsToBlink.forEach(region => {
            const el = document.getElementById(`region-${region.id}`);
            if (el) {
                el.classList.add('R_CRITICAL_BLITZ');
            }
        });

        // Wait for the blinking to finish (5000ms is the duration set by BLINK_DURATION_MS)
        setTimeout(() => {
            // Remove the blinking class after the duration
            regionsToBlink.forEach(region => {
                const el = document.getElementById(`region-${region.id}`);
                if (el) {
                    el.classList.remove('R_CRITICAL_BLITZ');
                }
            });
            // Execute the original phase action
            callback();
        }, BLINK_DURATION_MS);
    }

    /**
     * 다음 단계로 진행 로직을 처리합니다.
     */
    function handlePhaseAdvance() {
        // 현재 단계 인덱스를 증가시키고, 끝에 도달하면 1단계(Young GC)로 돌아갑니다.
        currentPhaseIndex = (currentPhaseIndex + 1) % phases.length;

        // 초기화 단계(0)는 건너뜁니다.
        if (currentPhaseIndex === 0) {
            currentPhaseIndex = 1;
        }

        // 버튼 텍스트를 현재 단계에 맞게 업데이트
        if (currentPhaseIndex > 1) {
            NEXT_PHASE_BTN.textContent = '다음 단계 진행';
        } else {
            NEXT_PHASE_BTN.textContent = '시뮬레이션 시작 (다음 단계)';
        }
    }


    // --- PHASE FUNCTIONS ---

    /** 0. 초기 힙 구성 */
    function setupInitialHeap(phaseName) {
        let numYoung = getRandomInt(20, 30);
        let numOld = getRandomInt(40, 50);
        let numHumongous = getRandomInt(1, 3);

        const emptyIndices = regions.map((_, i) => i);
        // Fisher-Yates shuffle
        for (let i = emptyIndices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [emptyIndices[i], emptyIndices[j]] = [emptyIndices[j], emptyIndices[i]];
        }

        let index = 0;
        // 1. Eden
        for (let i = 0; i < Math.floor(numYoung * 0.8); i++) {
            setRegionState(regions[emptyIndices[index++]], RegionTypes.EDEN, phaseName, "새 객체로 채워짐");
        }
        // 2. Survivor
        for (let i = 0; i < Math.ceil(numYoung * 0.2); i++) {
            setRegionState(regions[emptyIndices[index++]], RegionTypes.SURVIVOR, phaseName, "Young GC를 겪은 객체");
        }
        // 3. Old
        for (let i = 0; i < numOld; i++) {
            setRegionState(regions[emptyIndices[index++]], RegionTypes.OLD, phaseName, "오래 살아남은 객체");
        }
        // 4. Humongous
        for (let i = 0; i < numHumongous; i++) {
            setRegionState(regions[emptyIndices[index++]], RegionTypes.HUMONGOUS, phaseName, "매우 큰 객체 (50% 초과)");
        }
    }

    /** 1. Young GC 시작: Initial Mark (STW) */
    function startYoungGC(phaseName) {
        // Find a random Eden region to represent the GC Root scan/Initial Mark
        const edenRegions = regions.filter(r => r.type === RegionTypes.EDEN);
        if (edenRegions.length > 0) {
            const rootRegion = edenRegions[getRandomInt(0, edenRegions.length - 1)];
            rootRegion.data_history.push({
                phase: phaseName,
                status: "GC Root에서 직접 참조되는 객체 마킹 중"
            });
        }
        CURRENT_PHASE_DISPLAY.textContent = `${phaseName} - Young GC의 첫 단계로 매우 짧은 STW 발생`;
    }

    /** 2. Young GC: Evacuation 및 Compaction 완료 */
    function evacuateYoung(phaseName) {
        const youngRegions = regions.filter(r => r.type === RegionTypes.EDEN || r.type === RegionTypes.SURVIVOR);
        const emptyRegions = regions.filter(r => r.type === RegionTypes.EMPTY);
        const CSET_SIZE = Math.min(youngRegions.length, 10);

        // 1. CSET Selection (All Young regions are implicitly in CSET for Young GC)
        youngRegions.forEach(r => setRegionState(r, RegionTypes.CSET, phaseName, "GC 대상으로 선정됨 (CSET 포함)"));

        // 2. To Space (New Survivor/Old)
        const toSpaceCount = Math.ceil(CSET_SIZE * 0.5); // Assume 50% survive
        for (let i = 0; i < Math.min(toSpaceCount, emptyRegions.length); i++) {
            setRegionState(emptyRegions[i], RegionTypes.TO_SPACE, phaseName, "생존 객체가 복사되는 새로운 리전");
        }

        // 3. Evacuation & Cleanup (Instantaneous change after selection)
        // CSET regions become EMPTY
        youngRegions.forEach(r => setRegionState(r, RegionTypes.EMPTY, phaseName, "객체 이동 완료 후 빈 리전으로 반환됨"));

        // TO_SPACE regions become Survivor or Old
        regions.filter(r => r.type === RegionTypes.TO_SPACE).forEach(r => {
            const newType = (r.live_objects > 1000 || Math.random() < 0.3) ? RegionTypes.OLD : RegionTypes.SURVIVOR;
            setRegionState(r, newType, phaseName, "객체가 성공적으로 이동 및 압축되어 새로운 리전이 됨");
        });

        CURRENT_PHASE_DISPLAY.textContent = `${phaseName} - Young/Survivor 객체가 새로운 리전으로 이동 및 압축됩니다. (STW)`;
    }

    /** 3. Old 영역 임계점 도달 (Start Concurrent Mark) */
    function startConcurrentMark(phaseName) {
        const oldRegions = regions.filter(r => r.type === RegionTypes.OLD);
        const oldRegionRatio = oldRegions.length / NUM_REGIONS;
        const oldRegionRatioPercent = Math.round(oldRegionRatio * 100);
        const thresholdPercent = Math.round(OLD_REGION_THRESHOLD * 100);

        // Force Old regions to grow for demonstration if needed, and check the ratio
        if (oldRegionRatio < OLD_REGION_THRESHOLD) {
            const emptyRegions = regions.filter(r => r.type === RegionTypes.EMPTY);
            // Increase Old regions to trigger the condition next time, or just visually acknowledge.
            for (let i = 0; i < Math.min(10, emptyRegions.length); i++) {
                setRegionState(emptyRegions[i], RegionTypes.OLD, phaseName, "Old 영역 사용률 임계점 미만, 객체 할당 지속");
            }
            CURRENT_PHASE_DISPLAY.textContent = `${phaseName} - 현재 Old 영역 사용률 ${oldRegionRatioPercent}% (임계점: ${thresholdPercent}%). 데모를 위해 Concurrent Cycle을 시작합니다.`;

        } else {
            CURRENT_PHASE_DISPLAY.textContent = `${phaseName} - 현재 Old 영역 사용률 ${oldRegionRatioPercent}% 로 임계점(${thresholdPercent}%)을 초과하여 Concurrent Cycle이 시작됩니다.`;
        }
    }

    /** 4. Concurrent Marking 진행 중 (동시 추적) */
    function processConcurrentMark(phaseName) {
        const oldRegions = regions.filter(r => r.type === RegionTypes.OLD);
        oldRegions.slice(0, Math.ceil(oldRegions.length * 0.7)).forEach(r => {
            r.data_history.push({ phase: phaseName, status: "애플리케이션과 동시에 객체 생존 여부 추적 중" });
        });
        CURRENT_PHASE_DISPLAY.textContent = `${phaseName} - STW 없이 백그라운드에서 Old 객체를 마킹합니다.`;
    }

    /** 5. Remark 및 Cleanup 완료 (STW) */
    function processRemarkCleanup(phaseName) {
        // Remark: short STW to finalize marking
        regions.filter(r => r.type === RegionTypes.OLD).forEach(r => {
            r.data_history.push({ phase: 'Remark (STW)', status: "동시 마킹 중 변경된 사항 최종 반영" });
        });

        // Cleanup: Identify completely empty regions
        const candidates = regions.filter(r => r.type === RegionTypes.OLD);
        if (candidates.length > 0) {
            const emptyCandidate = candidates[getRandomInt(0, candidates.length - 1)];
            setRegionState(emptyCandidate, RegionTypes.EMPTY, phaseName, "가비지만 100% 남은 리전을 발견, 즉시 Empty로 반환");
        }

        CURRENT_PHASE_DISPLAY.textContent = `${phaseName} - 최종 마킹 및 완전히 비어있는 리전을 힙에 반환합니다. (짧은 STW)`;
    }

    /** 6. Mixed GC 시작: CSET 선정 */
    function startMixedGC(phaseName) {
        // Select Young, Survivor, and Old regions for CSET based on Max Pause Time Target
        const candidates = regions.filter(r => r.type !== RegionTypes.EMPTY && r.type !== RegionTypes.HUMONGOUS);
        const CSET_SIZE = Math.min(candidates.length, 15);

        // Select the "most garbage-filled" candidates (simulated by random selection here)
        const CSET_regions = candidates
            .sort(() => 0.5 - Math.random()) // Shuffle
            .slice(0, CSET_SIZE);

        CSET_regions.forEach(r => setRegionState(r, RegionTypes.CSET, phaseName, "가장 효율적인 청소 대상으로 선정됨 (Max Pause Time 목표 준수)"));

        // Select Empty regions as TO_SPACE
        const emptyRegions = regions.filter(r => r.type === RegionTypes.EMPTY);
        const toSpaceCount = Math.ceil(CSET_SIZE * 0.6); // Assume a survival rate
        for (let i = 0; i < Math.min(toSpaceCount, emptyRegions.length); i++) {
            setRegionState(emptyRegions[i], RegionTypes.TO_SPACE, phaseName, "CSET의 살아있는 객체를 복사할 임시 공간");
        }

        CURRENT_PHASE_DISPLAY.textContent = `${phaseName} - Mixed GC가 시작됩니다. Young과 Old 리전이 CSET으로 선정됩니다. (STW)`;
    }

    /** 7. Mixed GC: Compaction 및 비우기 완료 */
    function evacuateMixed(phaseName) {
        const CSET_regions = regions.filter(r => r.type === RegionTypes.CSET);

        // Evacuation & Cleanup (Instantaneous change after selection)
        // CSET regions become EMPTY
        CSET_regions.forEach(r => setRegionState(r, RegionTypes.EMPTY, phaseName, "객체 이동 완료 후 빈 리전으로 반환됨"));

        // TO_SPACE regions become Survivor or Old
        regions.filter(r => r.type === RegionTypes.TO_SPACE).forEach(r => {
            const newType = (r.live_objects > 1000 || Math.random() < 0.5) ? RegionTypes.OLD : RegionTypes.SURVIVOR;
            setRegionState(r, newType, phaseName, "새로운 Old/Survivor 리전으로 최종 확정됨 (Compaction 완료)");
        });

        CURRENT_PHASE_DISPLAY.textContent = `${phaseName} - Evacuation 완료. CSET 리전들은 이제 비워지고 압축됩니다.`;
    }

    /** 8. 휴먼저스 객체 처리 (Optional Cleanup) */
    function processHumongous(phaseName) {
        const humongousRegions = regions.filter(r => r.type === RegionTypes.HUMONGOUS);
        if (humongousRegions.length > 0) {
            const cleanupCandidate = humongousRegions[getRandomInt(0, humongousRegions.length - 1)];
            if (Math.random() < 0.7) { // 70% chance to be collected
                setRegionState(cleanupCandidate, RegionTypes.EMPTY, phaseName, "더 이상 참조되지 않아 제거됨");
            } else {
                cleanupCandidate.data_history.push({ phase: phaseName, status: "아직 참조 중이므로 유지됨" });
            }
        }
        CURRENT_PHASE_DISPLAY.textContent = `${phaseName} - 큰 객체(Humongous) 중 가비지를 제거합니다.`;
    }

    /**
     * 다음 단계로 진행합니다. (Updated to include blinking)
     */
    function goToNextPhase() {
        // Prevent multiple clicks while blinking
        if (NEXT_PHASE_BTN.disabled) return;

        const phase = phases[currentPhaseIndex];

        // 1. Identify regions that will be affected by this phase (before running action)
        let regionsToBlink = getRegionsForBlink(phase.name);

        if (regionsToBlink.length > 0) {
            // Blinking required for critical action (Evacuation/Cleanup)
            NEXT_PHASE_BTN.disabled = true;
            NEXT_PHASE_BTN.textContent = `GC 진행 중: ${phase.name.split(':')[0]} 점멸 중 (5초)...`;

            blinkRegions(regionsToBlink, () => {
                // 2. Execute the phase action after blinking
                phase.action(phase.name);
                updateRegionClasses();
                handlePhaseAdvance();
                NEXT_PHASE_BTN.disabled = false;
            });
        } else {
            // No critical regions to blink (e.g., setup, mark, threshold detection)
            phase.action(phase.name);
            updateRegionClasses();
            handlePhaseAdvance();
        }
    }

    /**
     * 초기 로드 시 실행됩니다.
     */
    window.onload = function() {
        // Event Listeners
        NEXT_PHASE_BTN.addEventListener('click', goToNextPhase);

        // Initial Setup: Phase 0 (Initial Heap Setup)
        initializeRegions();
        renderRegions();
        // Run initial setup phase once
        phases[0].action(phases[0].name);
        updateRegionClasses();
        currentPhaseIndex = 1; // Start from Young GC on first run

        CURRENT_PHASE_DISPLAY.textContent = `${phases[0].name} 완료. '시뮬레이션 시작'을 눌러 다음 단계(Young GC)로 진행하세요.`;
    };

</script>
</body>
</html>