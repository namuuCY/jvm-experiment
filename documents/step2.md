# Step 2: JVM 부하 유형별 맞춤형 튜닝 실험


## **[2A]** N-Queen 에서의 JVM 옵션 튜닝

- N-Queen 문제는 기본적으로 재귀 호출이 깊고, 연산 위주의 작업을 하고 있습니다.
- 성능을 가르는 핵심은 JIT 컴파일러의 기계어 변환 능률과 스레드/스택 관리에 있다고 생각했습니다.
- 이를 조정하는 몇 가지 옵션을 가지고 튜닝 실험을 진행해보겠습니다.


### N-Queen 공통 실험 환경
- n = 15 (15 X 15 체스판)
  - 30초 이하, 실험을 위한 적절한 시간대를 위하여 선정한 파라미터 입니다.
- JVM 옵션
  - `-Xms512m -Xmx512m` : 혹시나 heap의 부족으로 인한 불필요한 변수가 생길것을 차단하기위해, 미리 넉넉한 Heap 사이즈를 강제합니다.
  - `-XX:+PrintFlagsFinal` : JVM 옵션을 출력합니다. 
    - 플랫폼(OS), 혹은 Intellij 에서 불필요한 옵션을 넣어 사이드 이펙트가 생기지 않도록, 옵션을 항상 확인합니다.
  - `-XX:-TieredCompilation` : 조사 결과 JIT의 Compile 최적화에는 수많은 요소가 들어가는 것으로 생각됩니다. JIT 튜닝을 위해 제가 넣은 옵션이 잘 동작할 수 있도록 변인을 통제하기 위해 설정합니다.
    - 초기 설정 오류(IDE 주입 옵션)를 제거하고 C2 컴파일러를 활성화하자 연산 속도가 약 40% 향상됨(초기 IDE의 설정에서는 약 22초)을 확인했습니다.
- **⭐️ OS 레벨의 캐싱(Disk I/O) 및 JVM Cold Start로 인한 노이즈를 배제하기 위해, 모든 실험은 3회 반복 실행한 후, 가장 안정화된 3회차 결과를 측정값으로 채택합니다.**


### Baseline 데이터
- Flag 옵션들 [🔗 링크](/documents/data/2A_Baseline.txt)
  - 실험을 위해 표기하는 몇 가지 중요 default 옵션
    - `CompileThreshold` : 10000
    - `ThreadStackSize` : 2048Kb = 2Mb
    - `MaxInlineSize` : 35byte
- 걸린 시간 : **13.6585 초**
![콘솔 출력 이미지](/documents/images/s2-2a-1-result.png)
- Heap 사이즈를 늘려도 GC가 두번 있긴 했으나, 합쳐도 5ms가 안되기에, 실험에 영향을 주지는 않을 것으로 판단됩니다. 
  - (전체 실행 시간 약 13.659ms 중 GC가 차지하는 시간은 5ms -> 0.03%)
![GC 이미지](/documents/images/s2-2a-baseline-gc.png)


### 2A-1 JIT 컴파일러의 빠른 개입

- N-queen 문제는 코드의 분기가 별로 없고, 동일한 코드가 재귀로 인해서 매우 빠르게 반복되어 호출되는 특성을 가지고 있습니다.
- 만약 N-queen 문제를 해결하는 메서드가 Hot 하다고 빨리 판단돼서, 해당 메서드를 빨리 컴파일을 하게 된다면 어떻게 될지 측정해봤습니다.
- **옵션 : `CompileThreshold=1000`** 
- 결과 텍스트 [🔗 링크](/documents/data/2A-1.txt)
- 걸린 시간 : **13.2325 초** (**약 0.4초 단축**)
- gc에 걸린시간은 합쳐서 약 4ms로 유의미한 gc의 STW 차이는 있지 않았습니다.

![2A-1 GC](/documents/images/s2-2a-1-gc.png)

- [결론] : 아주 미세한 최적화가 이뤄졌습니다(혹은 유의미한 변화라고 판단하지 않을수도 있습니다). N-Queen은 워낙 반복이 많아 Default 설정으로도 금방 컴파일되기 때문입니다.

### 2A-2 스레드의 stack 메모리 할당 최적화

- 지금의 N-Queen 문제는 stack의 깊은 재귀 호출로 인해 Stack Memory 사용량이 중요합니다. 
- `-Xss128k`로 도전했으나, 다음과 같은 에러를 내뿜었습니다.
![2A-2 error](/documents/images/s2-2a-2-error.png)
- 에러에서 얘기한 것과 같이, 208k 로 다시 시도해 보았습니다.
- 결과 텍스트 [🔗 링크](/documents/data/2A-2.txt)
- 걸린 시간 : **13.4373** (**약 0.2초 단축**)
![콘솔 출력 이미지](/documents/images/s2-2a-2-result.png)
- gc에 걸린시간은 두 번에 걸쳐 일어났고, 두 gc를 합쳐서 약 4ms로 동일합니다.
![gc 이미지](/documents/images/s2-2a-2-gc.png)
- [결론] 이정도의 재귀 깊이를 가진 상태에서 default인 2048Kb의 스택 메모리 할당은 과도할 수 있다고 생각됩니다.
  - 성능을 유지하면서 메모리 사용량(Stack)을 1/10로 줄였으므로 자원 효율성 개선이 되었다고 볼 수 있습니다.


### 2A-3 JIT 컴파일러의 Inlining 임계값 변화에 따른 성능 영향력 분석

- `MaxInlineSize`는 JVM의 JIT 컴파일러가 런타임에 메서드를 최적화할 때, 메서드 호출 오버헤드를 제거하기 위해 코드를 호출부로 합치는 인라이닝(Inlining)의 최대 바이트코드 크기 임계값을 결정합니다.
- N-Queen의 핵심 로직인 isSafe 메서드의 크기를 고려하여, 임계값을 넉넉하게 늘렸을 때 추가적인 최적화가 발생하는지 비교해보겠습니다.
- `-XX:MaxInlineSize=100`
  - 걸린 시간 : **13.4350** (**약 0.2초 단축**)
  - 결과 텍스트 [🔗 링크](/documents/data/2A-3-a.txt)
  - ![콘솔 출력 이미지](/documents/images/s2-2a-3-1-result.png)`
- [결론] 이 경우는 그렇게 유의미한 최적화라고 보기 힘들 것 같습니다.
  - 이는 MaxInlineSize 보다 메서드가 크더라도, JVM이 자주 호출되는 메서드에 대해서는 FreqInlineSize(기본 325byte) 기준을 적용하여 이미 인라이닝을 수행하고 있기 때문으로 분석됩니다.
  - 즉, N-Queen 알고리즘에서는 기본 JVM 설정만으로도 이미 충분한 인라이닝 최적화가 이루어지고 있음을 확인했습니다.



